import os
import requests
import pprint
from fake_headers import Headers
from urllib.parse import urljoin
from VulnerabilityScanner.Injections import Injections

class XssScanner(Injections):

    def __init__(self, quiet, url, vulnerabilities_tracker):
        super().__init__(quiet)
        self.url = url
        self.quiet = quiet
        self.vulnerabilities_tracker = vulnerabilities_tracker
        self.header = Headers(headers=True)
        self.ses = requests.Session()

    def scan_host(self, report, xsspayload):
        """
        Perform XSS scan
        Args:
            report: Report file object
            xsspayload: script argument pointing to XSS payloads file
        """
        if not self.quiet:
            print("[*] Checking for XSS vulnerabilities")

        # Get all forms in the HTML
        forms = self.get_all_forms_html(self.url)
        report.write_to_report("\n Number of detected forms in URL: " + str(len(forms)) + "\n")

        # Determine the payload file
        payloadfile = "./payloads/xss_payloads.txt" if not xsspayload else xsspayload
        if os.path.isfile(payloadfile):
           with open(payloadfile, "r", encoding="utf-8") as f:
                payloads = f.readlines()
        else:
            print("Payload file does not exist.")
            return
        print("Please be patient while the scanner is running...")
        # Iterate through forms and payloads to check for vulnerabilities
        for form in forms:
            f_details = self.get_form_details(form)
            for script in payloads:
                script = script.strip()
                form_data = self.prepare_form_data(f_details, script)
                response = self.submit_form(f_details['action'], f_details['method'], form_data)

                # Check if the script is in the response content
                if script in response.text:
                    unique_id = (f_details['action'], tuple(input['name'] for input in f_details['inputs']))

                    # Check if the vulnerability is already tracked
                    if unique_id not in self.vulnerabilities_tracker:
                        self.vulnerabilities_tracker.add(unique_id)

                        if not self.quiet:
                            print("[-] Found XSS vulnerability")
                            xss_details_url = self.get_full_url(f_details['action'])
                            print("Link: " + xss_details_url)
                            print("XSS Details -> " + f_details['action'])
                            

                            

                        # Write to the report
                        report.write_to_report("\n[Vulnerability] Found XSS vulnerability in form! :" + xss_details_url +"\n")
                        report.write_to_report(pprint.pformat(f_details))
        print("Scan completed")
        self.close_session()


    def get_full_url(self, path):

        return urljoin(self.url, path if path else self.url)


    @staticmethod
    def prepare_form_data(f_details, script):
        """
        Prepare form with JS payload
        Args:
            f_details: Details of the form
            script: JS payload
        Returns:
        """
        form_data = {}
        for input_element in f_details['inputs']:
            # Default to using the input element's original value
            input_value = input_element.get('value', '')

            # Inject payload into text and textarea inputs
            if input_element['type'] in ('text', 'textarea'):
                input_value = script
            elif input_element['type'] == 'submit':
                input_value = input_element.get('value', '')

            form_data[input_element['name']] = input_value

        return form_data

    def submit_form(self, action_url, method, form_data):
        """
        Submits a form with the injected script (XSS payload) and returns the response.
        Args:
            action_url: URL that will be entered
            method: Request method
            form_data: Data obtained from HTML form
        Returns: HTTP response
        """
        url = urljoin(self.url, action_url if action_url else self.url)
    
         # Use the with statement to automatically close the session
        with requests.Session() as ses:
          if method == "post":
            response = ses.post(url, data=form_data, headers=self.header.generate())
          else:  # Default to GET if not POST
            response = ses.get(url, params=form_data, headers=self.header.generate())
    
        return response
    def close_session(self):
        """
        Close the session to release resources.
        """
        self.ses.close()

    #deneme commiti