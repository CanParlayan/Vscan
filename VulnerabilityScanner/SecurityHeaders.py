import re
import urllib.request
from urllib.error import URLError, HTTPError


def load_headers_from_file(file_path):
    headers = []
    try:
        with open(file_path, 'r') as file:
            for line in file:
                header_info = line.strip().split(',')
                if len(header_info) == 2:
                    headerName, deprecated = header_info
                    headers.append({"name": headerName, "deprecated": deprecated.lower() == "true"})
    except FileNotFoundError:
        print("Headers file not found.")
    return headers


def check_header(res, report, header_info):
    headerName = header_info["name"]
    deprecated = header_info["deprecated"]

    print(f"Checking for header: {headerName}")
    print(f"Response headers: {res.headers}")

    if res.getheader(headerName):
        if deprecated:
            report.write_to_report(
                f"{headerName}")
    else:
        report.write_to_report(
            f"{headerName}")


def parse_cspHeader(header):
    cspDirectioves = {}
    directives = re.findall(r'([a-zA-Z-]+)\s+([^\s;]+)', header)
    for directive, value in directives:
        cspDirectioves[directive] = value
    return cspDirectioves


def check_csp_for_misconfigurations(cspHeader):
    misconfigurations = []
    cspDirectioves = parse_cspHeader(cspHeader)

    scriptSRC = cspDirectioves.get('script-components', '')

    if "'unsafe-inline'" in scriptSRC:
        misconfigurations.append("Inline scripts are allowed (unsafe-inline)")

    if "'unsafe-eval'" in scriptSRC:
        misconfigurations.append("Eval is allowed (unsafe-eval)")

    if "'unsafe-hashes'" in scriptSRC:
        misconfigurations.append("Unsafe hashes are allowed (unsafe-hashes)")

    if "'*'" in scriptSRC:
        misconfigurations.append("Scripts can be loaded from any origin (*)")

    allow_listed_sources = scriptSRC.split()
    for source in allow_listed_sources:
        if source.startswith('http://') or source.startswith('https://'):
            if 'jsonp' in source.lower():
                misconfigurations.append(f"JSONP endpoint found in allow list: {source}")

    if "'*'" in cspDirectioves.get('frame-ancestors', ''):
        misconfigurations.append("Framing is enabled for all origins (*)")

    return misconfigurations


class SecurityHeaders:
    def __init__(self, given_url, quiet, no_https):
        self.url = given_url
        self.quiet = quiet
        self.headers_to_check = load_headers_from_file("./payloads/headers.txt")
        self.urls_missing_hsts = []
        if not no_https:
            self.headers_to_check.append({"name": "Strict-Transport-Security", "deprecated": False})

    def check_security_headers(self, report, url):
        try:
            res = urllib.request.urlopen(self.url)
        except (HTTPError, URLError):
            return report

        for header_info in self.headers_to_check:
            headerName = header_info["name"]

            if not res.getheader(headerName):
                recommendation = f"{headerName}"
                report.write_to_report(recommendation, "headerCheck", url=url)

        cspHeader = res.headers.get('Content-Security-Policy', '')
        misconfigurations = check_csp_for_misconfigurations(cspHeader)
        for misconfig in misconfigurations:
            report.write_to_report(misconfig, "cpsMisconfigurations", url=url)

        cspclickjack = "'frame-ancestors' in cspHeader and '*' in cspHeader['frame-ancestors']"
        xframeclickjack = ("'X-Frame-Options' not in res.headers or res.headers['X-Frame-Options'] not in ['deny', "
                           "'sameorigin']")

        ClickjackClass.check_clickjack(report, cspclickjack=cspclickjack, xframeclickjack=xframeclickjack, url=self.url)

        return report

    def get_urls_missing_hsts(self):
        return self.urls_missing_hsts


class HeaderCheckerFactory:
    @staticmethod
    def create_headerChecker(headerName):
        if headerName == "X-Frame-Options":
            return XFrameOptionsChecker()
        elif headerName == "X-Content-Type-Options":
            return XContentTypeOptionsChecker()
        elif headerName == "X-Download-Options":
            return XDownloadOptionsChecker()
        elif headerName == "Cache-Control":
            return CacheControlChecker()
        elif headerName == "X-Permitted-Cross-Domain-Policies":
            return XPermittedCrossDomainPoliciesChecker()
        else:
            return DefaultHeaderChecker(headerName)


class DefaultHeaderChecker:
    def __init__(self, headerName=None):
        self.headerName = headerName

    def check_header_value(self, res, report):
        pass


class XFrameOptionsChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Frame-Options')

    def check_header_value(self, res, report):
        header_value = res.headers.get(self.headerName, '').lower()
        if header_value not in ['deny', 'sameorigin']:
            report.write_to_report(
                f"{self.headerName}"
            )


class XContentTypeOptionsChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Content-Type-Options')

    def check_header_value(self, res, report):
        header_value = res.headers.get(self.headerName, '').lower()
        if header_value != 'nosniff':
            report.write_to_report(
                f"[Recommendation] Header {self.headerName}"
                f" not found or not properly configured, please implement security header!"
            )


class XDownloadOptionsChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Download-Options')

    def check_header_value(self, res, report):
        header_value = res.headers.get(self.headerName, '').lower()
        if header_value != 'noopen':
            report.write_to_report(
                f"[Recommendation] File Download security is OFF, header {self.headerName}"
                f" not found or not properly configured, please implement security header!"
            )


class CacheControlChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('Cache-Control')

    def check_header_value(self, res, report):
        cache_control = res.headers.get(self.headerName, '').lower()
        if not (cache_control.startswith('private') or cache_control.startswith('no-cache')):
            report.write_to_report(
                f"[Recommendation] No content caching policy, header {self.headerName}"
                f" not found or not properly configured, please implement security header!"
            )


class XPermittedCrossDomainPoliciesChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Permitted-Cross-Domain-Policies')

    def check_header_value(self, res, report):
        header_value = res.headers.get(self.headerName, '').lower()
        if header_value not in ['master-only', 'none']:
            report.write_to_report(
                f"{self.headerName} header not found or not properly configured, please implement security header!"
            )


class ClickjackClass:
    @staticmethod
    def check_clickjack(report, cspclickjack, xframeclickjack, url):
        clickjack = cspclickjack and xframeclickjack
        if clickjack:
            report.write_to_report("Yes", "clickjacking", url=url)
        else:
            report.write_to_report("No", "clickjacking", url=url)
