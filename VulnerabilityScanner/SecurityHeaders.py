import urllib.request
from urllib.error import URLError, HTTPError
import re

class SecurityHeaders:
    def __init__(self, givenurl, quiet, nohttps):
        self.url = givenurl
        self.quiet = quiet
        self.headers_to_check = self.load_headers_from_file("./payloads/headers.txt")

        if not nohttps:
            self.headers_to_check.append({"name": "Strict-Transport-Security", "deprecated": False})

    def load_headers_from_file(self, file_path):
        headers = []
        try:
            with open(file_path, 'r') as file:
                for line in file:
                    header_info = line.strip().split(',')
                    if len(header_info) == 2:
                        header_name, deprecated = header_info
                        headers.append({"name": header_name, "deprecated": deprecated.lower() == "true"})
        except FileNotFoundError:
            print("Headers file not found.")
        return headers

    global cspClickjack
    cspClickjack = False

    global xframeClickjack
    xframeClickjack = False

    def check_security_headers(self, report):

        global cspClickjack
        global xframeClickjack


        if not self.quiet:
            print("[*] Checking security headers")

        try:
            res = urllib.request.urlopen(self.url)
        except (HTTPError, URLError):
            return

        report.write_to_report(f"\n [*****] Security headers returned by URL: {self.url}: [*****] \n \n")

        # Check CSP header
        csp_header = res.headers.get('Content-Security-Policy')
        if csp_header:
            misconfigurations = self.check_csp_for_misconfigurations(csp_header)
            if misconfigurations:
                cspClickjack = True
                report.write_to_report("Misconfigurations found in Content-Security-Policy:\n")
                for misconfig in misconfigurations:
                    report.write_to_report("- {}\n".format(misconfig))  
            else:
                report.write_to_report("No misconfigurations found in Content-Security-Policy.\n")
                cspClickjack = False
        else:
            cspClickjack = True


        for header_info in self.headers_to_check:
            self.check_header(res, report, header_info)
  
        clickjackClass.check_clickjack(report, cspClickjack, xframeClickjack)    

    def check_header(self, res, report, header_info):
        header_name = header_info["name"]
        deprecated = header_info["deprecated"]

        if res.getheader(header_name):
            if deprecated:
                report.write_to_report("[Deprecated] header found: " + header_name + " , please switch to secure header \n")
        else:
            report.write_to_report("[Recommendation] header " + header_name + " not found, consider implementing it! \n")

        header_checker = HeaderCheckerFactory.create_header_checker(header_name)
        header_checker.check_header_value(res, report)

    def check_csp_for_misconfigurations(self, csp_header):
        misconfigurations = []
        csp_directives = self.parse_csp_header(csp_header)

        # Check for unsafe-inline directive
        if "'unsafe-inline'" in csp_directives.get('script-src', ''):
            misconfigurations.append("Inline scripts are allowed (unsafe-inline)")

        # Check for unsafe-eval directive
        if "'unsafe-eval'" in csp_directives.get('script-src', ''):
            misconfigurations.append("Eval is allowed (unsafe-eval)")

        # Check for unsafe-hashes directive
        if "'unsafe-hashes'" in csp_directives.get('script-src', ''):
            misconfigurations.append("Unsafe hashes are allowed (unsafe-hashes)")

        # Check for wildcard (*) source
        if "'*'" in csp_directives.get('script-src', ''):
            misconfigurations.append("Scripts can be loaded from any origin (*)")

        # Check for allow listed sources with potential JSONP endpoints
        allow_listed_sources = csp_directives.get('script-src', '').split()
        for source in allow_listed_sources:
            if source.startswith('http://') or source.startswith('https://'):
                if 'jsonp' in source.lower():
                    misconfigurations.append("JSONP endpoint found in allow list: {}".format(source))

        # Check for wildcard (*) source in frame-ancestors directive
        if "'*'" in csp_directives.get('frame-ancestors', ''):
            misconfigurations.append("Framing is enabled for all origins (*)")

        return misconfigurations

    def parse_csp_header(self, header):
        csp_directives = {}
        directives = re.findall(r'([a-zA-Z-]+)\s+([^\s;]+)', header)
        for directive, value in directives:
            csp_directives[directive] = value
        return csp_directives

class HeaderCheckerFactory:
    @staticmethod
    def create_header_checker(header_name):
        if header_name == "X-Frame-Options":
            return XFrameOptionsChecker()
        elif header_name == "X-Content-Type-Options":
            return XContentTypeOptionsChecker()
        elif header_name == "X-Download-Options":
            return XDownloadOptionsChecker()
        elif header_name == "Cache-Control":
            return CacheControlChecker()
        elif header_name == "X-Permitted-Cross-Domain-Policies":
            return XPermittedCrossDomainPoliciesChecker()
        else:
            return DefaultHeaderChecker(header_name)

class DefaultHeaderChecker:
    def __init__(self, header_name=None):
        self.header_name = header_name

    def check_header_value(self, res, report):
        pass  # Implement default logic if needed

class XFrameOptionsChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Frame-Options')
    def check_header_value(self, res, report):
        global xframeClickjack
        # Check specific logic for X-Frame-Options header
        header_value = res.headers.get(self.header_name, '').lower()
        if header_value not in ['deny', 'sameorigin']:
            xframeClickjack = True     
            report.write_to_report("[Recommendation] header {} not found or not properly configured, please implement security header! \n".format(self.header_name))
        else:
            xframeClickjack = False    

class XContentTypeOptionsChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Content-Type-Options')

    def check_header_value(self, res, report):
        # Check specific logic for X-Content-Type-Options header
        header_value = res.headers.get(self.header_name, '').lower()
        if header_value != 'nosniff':
            report.write_to_report("[Recommendation] header {} not found or not properly configured, please implement security header! \n".format(self.header_name))

class XDownloadOptionsChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Download-Options')

    def check_header_value(self, res, report):
        # Check specific logic for X-Download-Options header
        header_value = res.headers.get(self.header_name, '').lower()
        if header_value != 'noopen':
            report.write_to_report("[Recommendation] File Download security is OFF, header {} not found or not properly configured, please implement security header! \n".format(self.header_name))

class CacheControlChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('Cache-Control')

    def check_header_value(self, res, report):
        # Check specific logic for Cache-Control header
        cache_control = res.headers.get(self.header_name, '').lower()
        if not (cache_control.startswith('private') or cache_control.startswith('no-cache')):
            report.write_to_report("[Recommendation] No content caching policy, header {} not found or not properly configured, please implement security header! \n".format(self.header_name))

class XPermittedCrossDomainPoliciesChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Permitted-Cross-Domain-Policies')

    def check_header_value(self, res, report):
        # Check specific logic for X-Permitted-Cross-Domain-Policies header
        header_value = res.headers.get(self.header_name, '').lower()
        if header_value not in ['master-only', 'none']:
            report.write_to_report("[Recommendation] {} header not found or not properly configured, please implement security header! \n".format(self.header_name))

class clickjackClass:
    @staticmethod
    def check_clickjack(report, cspClickjack, xframeClickjack):
        clickjack = cspClickjack and xframeClickjack
        
        if clickjack == True:
            report.write_to_report("[Alert] Possible clickjacking vulnerability detected.\n")
        else:
            report.write_to_report("[Alert] No clickjacking vulnerability detected.\n")
