import urllib.request
from urllib.error import URLError, HTTPError

class SecurityHeaders:
    def __init__(self, givenurl, quiet, nohttps):
        self.url = givenurl
        self.quiet = quiet
        self.headers_to_check = self.load_headers_from_file("./payloads/headers.txt")

        if not nohttps:
            self.headers_to_check.append({"name": "Strict-Transport-Security", "deprecated": False})

    def load_headers_from_file(self, file_path):
        headers = []
        try:
            with open(file_path, 'r') as file:
                for line in file:
                    header_info = line.strip().split(',')
                    if len(header_info) == 2:
                        header_name, deprecated = header_info
                        headers.append({"name": header_name, "deprecated": deprecated.lower() == "true"})
        except FileNotFoundError:
            print("Headers file not found.")
        return headers

    def check_security_headers(self, report):
        if not self.quiet:
            print("[*] Checking security headers")

        try:
            res = urllib.request.urlopen(self.url)
        except (HTTPError, URLError):
            return

        report.write_to_report(f"\n [*****] Security headers returned by URL: {self.url}: [*****] \n \n")

        for header_info in self.headers_to_check:
            self.check_header(res, report, header_info)

    def check_header(self, res, report, header_info):
        header_name = header_info["name"]
        deprecated = header_info["deprecated"]

        if res.getheader(header_name):
            if deprecated:
                report.write_to_report("[Deprecated] header found: " + header_name + " , please switch to secure header \n")
        else:
            report.write_to_report("[Recommendation] header " + header_name + " not found, consider implementing it! \n")

        header_checker = HeaderCheckerFactory.create_header_checker(header_name)
        header_checker.check_header_value(res, report)

class HeaderCheckerFactory:
    @staticmethod
    def create_header_checker(header_name):
        if header_name == "X-Frame-Options":
            return XFrameOptionsChecker()
        elif header_name == "X-Content-Type-Options":
            return XContentTypeOptionsChecker()
        elif header_name == "X-Download-Options":
            return XDownloadOptionsChecker()
        elif header_name == "Cache-Control":
            return CacheControlChecker()
        elif header_name == "X-Permitted-Cross-Domain-Policies":
            return XPermittedCrossDomainPoliciesChecker()
        else:
            return DefaultHeaderChecker(header_name)

class DefaultHeaderChecker:
    def __init__(self, header_name=None):
        self.header_name = header_name

    def check_header_value(self, res, report):
        pass  # Implement default logic if needed

class XFrameOptionsChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Frame-Options')
    def check_header_value(self, res, report):
        # Check specific logic for X-Frame-Options header
        header_value = res.headers.get(self.header_name, '').lower()
        if header_value not in ['deny', 'sameorigin']:
            report.write_to_report("[Recommendation] header {} not found or not properly configured, please implement security header! \n".format(self.header_name))
class XContentTypeOptionsChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Content-Type-Options')

    def check_header_value(self, res, report):
        # Check specific logic for X-Content-Type-Options header
        header_value = res.headers.get(self.header_name, '').lower()
        if header_value != 'nosniff':
            report.write_to_report("[Recommendation] header {} not found or not properly configured, please implement security header! \n".format(self.header_name))

class XDownloadOptionsChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Download-Options')

    def check_header_value(self, res, report):
        # Check specific logic for X-Download-Options header
        header_value = res.headers.get(self.header_name, '').lower()
        if header_value != 'noopen':
            report.write_to_report("[Recommendation] File Download security is OFF, header {} not found or not properly configured, please implement security header! \n".format(self.header_name))

class CacheControlChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('Cache-Control')

    def check_header_value(self, res, report):
        # Check specific logic for Cache-Control header
        cache_control = res.headers.get(self.header_name, '').lower()
        if not (cache_control.startswith('private') or cache_control.startswith('no-cache')):
            report.write_to_report("[Recommendation] No content caching policy, header {} not found or not properly configured, please implement security header! \n".format(self.header_name))

class XPermittedCrossDomainPoliciesChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Permitted-Cross-Domain-Policies')

    def check_header_value(self, res, report):
        # Check specific logic for X-Permitted-Cross-Domain-Policies header
        header_value = res.headers.get(self.header_name, '').lower()
        if header_value not in ['master-only', 'none']:
            report.write_to_report("[Recommendation] {} header not found or not properly configured, please implement security header! \n".format(self.header_name))
