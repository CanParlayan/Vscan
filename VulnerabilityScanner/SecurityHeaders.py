import re
import urllib.request
from urllib.error import URLError, HTTPError


def load_headers_from_file(file_path):
    headers = []
    try:
        with open(file_path, 'r') as file:
            for line in file:
                header_info = line.strip().split(',')
                if len(header_info) == 2:
                    header_name, deprecated = header_info
                    headers.append({"name": header_name, "deprecated": deprecated.lower() == "true"})
    except FileNotFoundError:
        print("Headers file not found.")
    return headers


def check_header(res, report, header_info):
    header_name = header_info["name"]
    deprecated = header_info["deprecated"]

    print(f"Checking for header: {header_name}")
    print(f"Response headers: {res.headers}")

    if res.getheader(header_name):
        if deprecated:
            report.write_to_report(
                f"[Deprecated] header found: {header_name}, please switch to secure header\n")
    else:
        report.write_to_report(
            f"[Recommendation] header {header_name} not found, consider implementing it!")


def parse_csp_header(header):
    csp_directives = {}
    directives = re.findall(r'([a-zA-Z-]+)\s+([^\s;]+)', header)
    for directive, value in directives:
        csp_directives[directive] = value
    return csp_directives


def check_csp_for_misconfigurations(csp_header):
    misconfigurations = []
    csp_directives = parse_csp_header(csp_header)

    script_src = csp_directives.get('script-components', '')

    if "'unsafe-inline'" in script_src:
        misconfigurations.append("Inline scripts are allowed (unsafe-inline)")

    if "'unsafe-eval'" in script_src:
        misconfigurations.append("Eval is allowed (unsafe-eval)")

    if "'unsafe-hashes'" in script_src:
        misconfigurations.append("Unsafe hashes are allowed (unsafe-hashes)")

    if "'*'" in script_src:
        misconfigurations.append("Scripts can be loaded from any origin (*)")

    allow_listed_sources = script_src.split()
    for source in allow_listed_sources:
        if source.startswith('http://') or source.startswith('https://'):
            if 'jsonp' in source.lower():
                misconfigurations.append(f"JSONP endpoint found in allow list: {source}")

    if "'*'" in csp_directives.get('frame-ancestors', ''):
        misconfigurations.append("Framing is enabled for all origins (*)")

    return misconfigurations


class SecurityHeaders:
    def __init__(self, given_url, quiet, no_https):
        self.url = given_url
        self.quiet = quiet
        self.headers_to_check = load_headers_from_file("./payloads/headers.txt")
        self.urls_missing_hsts = []
        if not no_https:
            self.headers_to_check.append({"name": "Strict-Transport-Security", "deprecated": False})

    def check_security_headers(self, report, url):
        try:
            res = urllib.request.urlopen(self.url)
        except (HTTPError, URLError):
            return report

        for header_info in self.headers_to_check:
            header_name = header_info["name"]

            if not res.getheader(header_name):
                recommendation = f"Header '{header_name}' not found, consider implementing it"
                report.write_to_report(recommendation, "header_check", url=url)

        csp_header = res.headers.get('Content-Security-Policy', '')
        misconfigurations = check_csp_for_misconfigurations(csp_header)
        for misconfig in misconfigurations:
            report.write_to_report(misconfig, "csp_misconfigurations", url=url)

        cspclickjack = "'frame-ancestors' in csp_header and '*' in csp_header['frame-ancestors']"
        xframeclickjack = ("'X-Frame-Options' not in res.headers or res.headers['X-Frame-Options'] not in ['deny', "
                           "'sameorigin']")

        ClickjackClass.check_clickjack(report, cspclickjack=cspclickjack, xframeclickjack=xframeclickjack, url=self.url)

        return report

    def get_urls_missing_hsts(self):
        return self.urls_missing_hsts


class HeaderCheckerFactory:
    @staticmethod
    def create_header_checker(header_name):
        if header_name == "X-Frame-Options":
            return XFrameOptionsChecker()
        elif header_name == "X-Content-Type-Options":
            return XContentTypeOptionsChecker()
        elif header_name == "X-Download-Options":
            return XDownloadOptionsChecker()
        elif header_name == "Cache-Control":
            return CacheControlChecker()
        elif header_name == "X-Permitted-Cross-Domain-Policies":
            return XPermittedCrossDomainPoliciesChecker()
        else:
            return DefaultHeaderChecker(header_name)


class DefaultHeaderChecker:
    def __init__(self, header_name=None):
        self.header_name = header_name

    def check_header_value(self, res, report):
        pass


class XFrameOptionsChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Frame-Options')

    def check_header_value(self, res, report):
        header_value = res.headers.get(self.header_name, '').lower()
        if header_value not in ['deny', 'sameorigin']:
            report.write_to_report(
                f"[Recommendation] Header {self.header_name}"
                f" not found or not properly configured, please implement security header!"
            )


class XContentTypeOptionsChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Content-Type-Options')

    def check_header_value(self, res, report):
        header_value = res.headers.get(self.header_name, '').lower()
        if header_value != 'nosniff':
            report.write_to_report(
                f"[Recommendation] Header {self.header_name}"
                f" not found or not properly configured, please implement security header!"
            )


class XDownloadOptionsChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Download-Options')

    def check_header_value(self, res, report):
        header_value = res.headers.get(self.header_name, '').lower()
        if header_value != 'noopen':
            report.write_to_report(
                f"[Recommendation] File Download security is OFF, header {self.header_name}"
                f" not found or not properly configured, please implement security header!"
            )


class CacheControlChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('Cache-Control')

    def check_header_value(self, res, report):
        cache_control = res.headers.get(self.header_name, '').lower()
        if not (cache_control.startswith('private') or cache_control.startswith('no-cache')):
            report.write_to_report(
                f"[Recommendation] No content caching policy, header {self.header_name}"
                f" not found or not properly configured, please implement security header!"
            )


class XPermittedCrossDomainPoliciesChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Permitted-Cross-Domain-Policies')

    def check_header_value(self, res, report):
        header_value = res.headers.get(self.header_name, '').lower()
        if header_value not in ['master-only', 'none']:
            report.write_to_report(
                f"{self.header_name} header not found or not properly configured, please implement security header!"
            )


class ClickjackClass:
    @staticmethod
    def check_clickjack(report, cspclickjack, xframeclickjack, url):
        clickjack = cspclickjack and xframeclickjack
        if clickjack:
            report.write_to_report("[Alert] Possible clickjacking vulnerability detected.", "clickjacking", url=url)
        else:
            report.write_to_report("[Alert] No clickjacking vulnerability detected.", "clickjacking", url=url)
