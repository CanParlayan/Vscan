import urllib.request
from urllib.error import URLError, HTTPError
import re

csp_clickjack = False
xframe_clickjack = False


def load_headers_from_file(file_path):
    headers = []
    try:
        with open(file_path, 'r') as file:
            for line in file:
                header_info = line.strip().split(',')
                if len(header_info) == 2:
                    header_name, deprecated = header_info
                    headers.append({"name": header_name, "deprecated": deprecated.lower() == "true"})
    except FileNotFoundError:
        print("Headers file not found.")
    return headers


def check_header(res, report, header_info):
    header_name = header_info["name"]
    deprecated = header_info["deprecated"]

    if res.getheader(header_name):
        if deprecated:
            report.write_to_report(
                "[Deprecated] header found: {}, please switch to secure header\n".format(header_name))
    else:
        report.write_to_report(
            "[Recommendation] header {} not found, consider implementing it!\n".format(header_name))

    header_checker = HeaderCheckerFactory.create_header_checker(header_name)
    header_checker.check_header_value(res, report)


def parse_csp_header(header):
    csp_directives = {}
    directives = re.findall(r'([a-zA-Z-]+)\s+([^\s;]+)', header)
    for directive, value in directives:
        csp_directives[directive] = value
    return csp_directives


def check_csp_for_misconfigurations(csp_header):
    global csp_clickjack

    misconfigurations = []
    csp_directives = parse_csp_header(csp_header)

    if "'unsafe-inline'" in csp_directives.get('script-src', ''):
        misconfigurations.append("Inline scripts are allowed (unsafe-inline)")

    if "'unsafe-eval'" in csp_directives.get('script-src', ''):
        misconfigurations.append("Eval is allowed (unsafe-eval)")

    if "'unsafe-hashes'" in csp_directives.get('script-src', ''):
        misconfigurations.append("Unsafe hashes are allowed (unsafe-hashes)")

    if "'*'" in csp_directives.get('script-src', ''):
        misconfigurations.append("Scripts can be loaded from any origin (*)")

    allow_listed_sources = csp_directives.get('script-src', '').split()
    for source in allow_listed_sources:
        if source.startswith('http://') or source.startswith('https://'):
            if 'jsonp' in source.lower():
                misconfigurations.append("JSONP endpoint found in allow list: {}".format(source))

    if "'*'" in csp_directives.get('frame-ancestors', ''):
        misconfigurations.append("Framing is enabled for all origins (*)")

    return misconfigurations


class SecurityHeaders:
    def __init__(self, givenurl, quiet, nohttps):
        self.url = givenurl
        self.quiet = quiet
        self.headers_to_check = load_headers_from_file("./payloads/headers.txt")

        if not nohttps:
            self.headers_to_check.append({"name": "Strict-Transport-Security", "deprecated": False})

    def check_security_headers(self, report):

        if not self.quiet:
            print("[*] Checking security headers")

        try:
            res = urllib.request.urlopen(self.url)
        except (HTTPError, URLError):
            return

        report.write_to_report("\n[*****] Security headers returned by URL: {}: [*****]\n\n".format(self.url))

        csp_header = res.headers.get('Content-Security-Policy')
        if csp_header:
            misconfigurations = check_csp_for_misconfigurations(csp_header)
            if misconfigurations:
                csp_var = True
                report.write_to_report("Misconfigurations found in Content-Security-Policy:\n")
                for misconfig in misconfigurations:
                    report.write_to_report("- {}\n".format(misconfig))
            else:
                report.write_to_report("No misconfigurations found in Content-Security-Policy.\n")
                csp_var = False
        else:
            csp_var = True

        for header_info in self.headers_to_check:
            check_header(res, report, header_info)

        ClickjackClass.check_clickjack(report, csp_var, xframe_clickjack)


class HeaderCheckerFactory:
    @staticmethod
    def create_header_checker(header_name):
        if header_name == "X-Frame-Options":
            return XFrameOptionsChecker()
        elif header_name == "X-Content-Type-Options":
            return XContentTypeOptionsChecker()
        elif header_name == "X-Download-Options":
            return XDownloadOptionsChecker()
        elif header_name == "Cache-Control":
            return CacheControlChecker()
        elif header_name == "X-Permitted-Cross-Domain-Policies":
            return XPermittedCrossDomainPoliciesChecker()
        else:
            return DefaultHeaderChecker(header_name)


class DefaultHeaderChecker:
    def __init__(self, header_name=None):
        self.header_name = header_name

    def check_header_value(self, res, report):
        pass


class XFrameOptionsChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Frame-Options')

    def check_header_value(self, res, report):
        global xframe_clickjack

        header_value = res.headers.get(self.header_name, '').lower()
        if header_value not in ['deny', 'sameorigin']:
            xframe_clickjack = True
            report.write_to_report(
                "[Recommendation] header {} not found or not properly configured, please implement security header!\n".format(
                    self.header_name))
        else:
            xframe_clickjack = False


class XContentTypeOptionsChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Content-Type-Options')

    def check_header_value(self, res, report):
        header_value = res.headers.get(self.header_name, '').lower()
        if header_value != 'nosniff':
            report.write_to_report(
                "[Recommendation] header {} not found or not properly configured, please implement security header!\n".format(
                    self.header_name))


class XDownloadOptionsChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Download-Options')

    def check_header_value(self, res, report):
        header_value = res.headers.get(self.header_name, '').lower()
        if header_value != 'noopen':
            report.write_to_report(
                "[Recommendation] File Download security is OFF, header {} not found or not properly configured, please implement security header!\n".format(
                    self.header_name))


class CacheControlChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('Cache-Control')

    def check_header_value(self, res, report):
        cache_control = res.headers.get(self.header_name, '').lower()
        if not (cache_control.startswith('private') or cache_control.startswith('no-cache')):
            report.write_to_report(
                "[Recommendation] No content caching policy, header {} not found or not properly configured, please implement security header!\n".format(
                    self.header_name))


class XPermittedCrossDomainPoliciesChecker(DefaultHeaderChecker):
    def __init__(self):
        super().__init__('X-Permitted-Cross-Domain-Policies')

    def check_header_value(self, res, report):
        header_value = res.headers.get(self.header_name, '').lower()
        if header_value not in ['master-only', 'none']:
            report.write_to_report(
                "{} header not found or not properly configured, please implement security header!\n".format(
                    self.header_name))


class ClickjackClass:
    @staticmethod
    def check_clickjack(report, cspclickjack, xframeclickjack):
        clickjack = cspclickjack and xframeclickjack
        if clickjack:
            report.write_to_report(
                "[Alert] Possible clickjacking vulnerability detected.\n")
        else:
            report.write_to_report(
                "[Alert] No clickjacking vulnerability detected.\n")
