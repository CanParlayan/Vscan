import os
import requests

from VulnerabilityScanner.Injections import Injections


def prepare_form_data(form_details, payload):
    return {input['name']: payload for input in form_details['inputs']}


class SQLiScanner(Injections):

    def __init__(self, quiet, url, vulnerabilities_tracker):
        super().__init__(quiet)
        self.url = url
        self.quiet = quiet
        self.vulnerabilities_tracker = vulnerabilities_tracker
        self.header = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, '
                                     'like Gecko) Chrome/91.0.4472.124 Safari/537.36'}
        self.ses = requests.Session()
        # Define a default payload here
        self.default_payload = "' OR 1=1 --"  # Example payload, customize as needed

    def scan_host(self, report, sqli_payloads):
        """
        Perform SQL Injection scan
        Args:
            report: Report file object
            sqli_payloads: script argument pointing to SQLi payloads file (optional)
        """
        if not self.quiet:
            print("[*] Checking for SQL Injection vulnerabilities")

        # Get all forms in the HTML
        forms = self.get_all_forms_html(self.url)
        report.write_to_report("\n Number of detected forms in URL: " + str(len(forms)) + "\n")

        # Use user-specified payload file if provided, otherwise use default
        payloadfile = sqli_payloads if sqli_payloads else "./payloads/sqli_payloads.txt"
        if os.path.isfile(payloadfile):
            with open(payloadfile, "r", encoding="utf-8") as f:
                payloads = f.readlines()
        else:
            print("Payload file does not exist. Using default payload.")
            payloads = [self.default_payload]

        print("Please be patient while the scanner is running...")

        # Iterate through forms and payloads to check for vulnerabilities
        for form in forms:
            f_details = self.get_form_details(form)
            for payload in payloads:
                payload = payload.strip()
                form_data = prepare_form_data(f_details, payload)
                response = self.submit_form(f_details['action'], f_details['method'], form_data)

                # Check if the payload is in the response content
                if payload in response.content.decode():
                    unique_id = (f_details['action'], tuple(input['name'] for input in f_details['inputs']))

                    # Check if the vulnerability is already tracked
                    if unique_id not in self.vulnerabilities_tracker:
                        self.vulnerabilities_tracker.add(unique_id)

                        sqli_details_url = None  # Initialize the variable before the block

                        if not self.quiet:
                            print("[-] Found SQL Injection vulnerability")
                            sqli_details_url = self.get_full_url(f_details['action'])
                            print("Link: " + sqli_details_url)
                            print("SQLi Details -> " + f_details['action'])

                        # Write to the report
                        report.write_to_report("\n[Vulnerability] Found SQL Injection vulnerability in form! :" +
                                               str(sqli_details_url) + "\n")
                        report.write_to_report(str(f_details))

        print("Scan completed")
        self.close_session()

    def submit_form(self, action, method, form_data):
        # Implement logic for submitting a form using requests
        response = self.ses.request(method, action, data=form_data)
        return response

    def get_full_url(self, action):
        # Check if action is not None before using urljoin
        if action:
            from urllib.parse import urljoin
            full_url = urljoin(self.url, action)
            return full_url
        else:
            # Handle the case where action is None (optional)
            return None  # Or raise an exception

    def close_session(self):
        # Implement logic to close the session
        self.ses.close()
