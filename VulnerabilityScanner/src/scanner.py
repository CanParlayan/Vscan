import multiprocessing
import os
import signal
import time
from urllib.parse import urlparse, urlunparse, parse_qs, urlencode

from VulnerabilityScanner.src.sqlerrors import check as check_sql_errors
from VulnerabilityScanner.src.web import web


def init():
    signal.signal(signal.SIGINT, signal.SIG_IGN)


def load_payloads_from_file(file_path):
    with open(file_path, 'r') as file:
        payloads = [line.strip() for line in file if line.strip()]
    return payloads


def scan(urls, payload_dir=None, threads=None):
    vulnerables = []

    max_processes = multiprocessing.cpu_count() * threads
    pool = multiprocessing.Pool(max_processes, init)

    results = {}

    for url in urls:
        result = pool.apply_async(scan_url, (url, payload_dir))
        results[url] = result

    try:
        while True:
            time.sleep(0.5)
            if all(result.ready() for result in results.values()):
                break
    except KeyboardInterrupt:
        pool.terminate()
        pool.join()
    else:
        pool.close()
        pool.join()

    for url, result in results.items():
        is_vulnerable, payload, vulnerable_url, vuln_type, response = result.get()
        if is_vulnerable:
            response_text = response.decode('utf-8') if isinstance(response, bytes) else response
            vulnerables.append({
                "URL": vulnerable_url,
                "Payload": payload,
                "Type": vuln_type,
                "SQL": check_sql_errors(response_text)
            })

    for vuln in vulnerables:
        print("Vulnerability Found:")
        print(f"URL: {vuln['URL']}")
        print(f"Payload: {vuln['Payload']}")
        print(f"Type: {vuln['Type']}")
        if vuln['SQL']:
            print("SQL found in response.")
        else:
            print("No SQL found in response.")
        print()

    return vulnerables


def inject_payload(url, payload):
    parsed_url = urlparse(url)
    if parsed_url.query:
        updated_query = parse_qs(parsed_url.query)
        for key in updated_query.keys():
            updated_query[key] = [payload]
        new_query = urlencode(updated_query, doseq=True)
        new_parsed_url = parsed_url._replace(query=new_query)
        return urlunparse(new_parsed_url)
    else:
        return url + '?' + urlencode([(key, payload) for key in payload])


def scan_url(url, payload_dir=None):
    parsed_url = urlparse(url)
    domain = parsed_url.scheme + "://" + parsed_url.netloc + parsed_url.path
    queries = parsed_url.query.split("&")

    if not any(queries):
        return False, None, None, None, None

    error_payload_file = union_payload_file = boolean_payload_file = time_payload_file = None
    if payload_dir:
        error_payload_file = os.path.join(payload_dir, "error_based_payload")
        union_payload_file = os.path.join(payload_dir, "union_based_payload")
        boolean_payload_file = os.path.join(payload_dir, "boolean_based_payload")
        time_payload_file = os.path.join(payload_dir, "time_based_payload")

    error_payloads = load_payloads_from_file(error_payload_file) if error_payload_file and os.path.isfile(
        error_payload_file) else []
    union_payloads = load_payloads_from_file(union_payload_file) if union_payload_file and os.path.isfile(
        union_payload_file) else []
    boolean_payloads = load_payloads_from_file(boolean_payload_file) if boolean_payload_file and os.path.isfile(
        boolean_payload_file) else []
    time_payloads = load_payloads_from_file(time_payload_file) if time_payload_file and os.path.isfile(
        time_payload_file) else []
    is_vulnerable = False
    vulnerable_payload = None
    vulnerable_url = None
    vuln_type = None
    response = None

    for error_payload in error_payloads:
        website = inject_payload(domain, error_payload)
        source = web.gethtml(website)
        if source:
            is_vulnerable = True
            vulnerable_payload = error_payload
            vulnerable_url = website
            vuln_type = "Error-Based Injection"
            response = source
            break

    if not is_vulnerable:
        for union_payload in union_payloads:
            website = inject_payload(domain, union_payload)
            source = web.gethtml(website)
            if source:
                is_vulnerable = True
                vulnerable_payload = union_payload
                vulnerable_url = website
                vuln_type = "Union-Based Injection"
                response = source
                break

    if not is_vulnerable:
        for boolean_payload in boolean_payloads:
            website_true = inject_payload(domain, boolean_payload + " AND 1=1")
            response_true = web.gethtml(website_true)

            website_false = inject_payload(domain, boolean_payload + " AND 1=0")
            response_false = web.gethtml(website_false)

            if response_true and response_false and response_true != response_false:
                is_vulnerable = True
                vulnerable_payload = boolean_payload
                vulnerable_url = domain
                vuln_type = "Boolean-Based Injection"
                response = response_true
                break

    if not is_vulnerable:
        for time_payload in time_payloads:
            start_time = time.time()
            website = inject_payload(domain, time_payload)
            response = web.gethtml(website)
            end_time = time.time()

            if response and end_time - start_time >= 10:
                is_vulnerable = True
                vulnerable_payload = time_payload
                vulnerable_url = domain
                vuln_type = "Time-Based Injection"
                break

    return is_vulnerable, vulnerable_payload, vulnerable_url, vuln_type, response
